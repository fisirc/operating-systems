# Project 2: User Programs

## Preliminaries

>Fill in your name and email address.

FirstName LastName <email@domain.example>

>If you have any preliminary comments on your submission, notes for the TAs,
>please give them here.

Nothing at all, excuse the mess.

>Please cite any offline or online sources you consulted while preparing your
>submission, other than the Pintos documentation, course text, lecture notes,
>and course staff.

The [OpenBSD](https://github.com/openbsd) codebase mainly, OpenBSD is known for
having a really clean and well structured codebase and served as quite the
inspiration.


## Argument Passing

#### DATA STRUCTURES

>A1: Copy here the declaration of each new or changed struct or struct member,
>global or static variable, typedef, or enumeration.  Identify the purpose of
>each in 25 words or less.

A `pcb` block was added to the `thread` def.:

```c
{
    ...
#ifdef USERPROG /* Owned by userprog/process.c. */
    uint32_t *pagedir; /**< Page directory. */
    struct proc_controlblock {
        enum process_stat {
            RUNNING,
            EXITED,
        } proc_stat;
        int xstat;
        struct semaphore wait_lock;
    } pcb;
#endif
    ...
}
```

#### ALGORITHMS

>A2: Briefly describe how you implemented argument parsing.  How do you arrange
>for the elements of argv[] to be in the right order?

The (80)x86 structure was followed as:

```
+ Data +________________
|                       |
|   argv[argc-1][...]   |
|   ...                 |
|   argv[1][...]        |
|   argv[0][...]        |
|                       |
+-----------------------+
|                       |
|   argv[argc]          |
|   ...                 |
|   argv[1]             |
|   argv[0]             |
|                       |
+-----------------------+
|   argv                |
|   argc                |
+-----------------------+
|   ret (0x00)          |
+-----------------------+
```

From top to bottom, arguments are passed by substract-and-copy using memcpy and
memset instead of raw pointer casting and dereferencing to avoid illegal
aliasing manipulation.

First, we create an array of `offsets` from each argument's head to the head of
the overall `cmd`, we store offsets instead of addresses because the whole
command line will be copied to the new stack page and the new baseline address
will be different.

Once the offsets are set, argpassing is just a matter of copying in order from
top to bottom into the page pointer.

A copy of the original intr. frame is used for a better memory alignment and
then reassigned as the new "start" of the stack.

```c
static void
start_process (void *_cmd UNUSED)
{
    char* cmd = (char*) _cmd;
    size_t cmd_len = strlen(cmd) + 1;

    char* file_name = NULL;
    char* cursor = cmd;

#define MAX_ARGC 512
    uint32_t argv_offset[MAX_ARGC];
    uint32_t argc = 0;

    char* tk = NULL;

    while ((tk = strtok_r(cursor, " ", &cursor))) {
        if (argc == 0) {
            file_name = tk;
            ASSERT(strlen(file_name) != 0);
            ASSERT(file_name != NULL);
        }

        argv_offset[argc] = tk - cmd;

        if (argc == MAX_ARGC)
            break;

        argc++;
    }

    /* Initialize interrupt frame and load executable. */
    struct intr_frame if_;
    memset (&if_, 0, sizeof if_);
    if_.gs = if_.fs = if_.es = if_.ds = if_.ss = SEL_UDSEG;
    if_.cs = SEL_UCSEG;
    if_.eflags = FLAG_IF | FLAG_MBS;

    bool success = load (file_name, &if_.eip, &if_.esp);
    if (!success)
        thread_exit();

    char* esp = (char*) if_.esp;
    esp -= cmd_len;

    // argv[0..argc][...]
    // may have a-little-too-big gaps
    memcpy(esp, cmd, cmd_len);

    char* argv_head = esp;

    // argv[argc] shall be NULL
    esp -= sizeof(void*);
    memset(esp, 0, sizeof(void*));

    // argv[0..argc]
    for (uint32_t index = argc - 1;; index--) {
        esp -= sizeof(char*);

        char* addr = argv_head + argv_offset[index];
        memcpy(esp, &addr, sizeof(char*));

        if (index == 0)
            break;
    }

    // argv ptr
    char* argv_ptr = esp;
    esp -= sizeof(char*);
    memcpy(esp, &argv_ptr, sizeof(char*));

    // argc
    esp -= sizeof(int);
    memcpy(esp, &argc, sizeof(int));

    // that one null
    esp -= sizeof(void*);
    memset(esp, 0, sizeof(void*));

    if_.esp = (void*) esp;
    //

    /* Start the user process by simulating a return from an
       interrupt, implemented by intr_exit (in
       threads/intr-stubs.S).  Because intr_exit takes all of its
       arguments on the stack in the form of a `struct intr_frame',
       we just point the stack pointer (%esp) to our stack frame
       and jump to it. */
    asm volatile ("movl %0, %%esp; jmp intr_exit" : : "g" (&if_) : "memory");
    NOT_REACHED ();
}

```


>How do you avoid overflowing the stack page?

A static size was given to the argv offsets list, args are truncated to that.

#### RATIONALE

>A3: Why does Pintos implement `strtok_r()` but not `strtok()`?

The original POSIX `strtok` function maintained a single global static state as
"cursor" during tokenization, which makes it thread-unsafe in scenarios where
multiple threads try to tokenize a string simultaneously.

>A4: In Pintos, the kernel separates commands into a executable name and
>arguments.  In Unix-like systems, the shell does this separation.  Identify at
>least two advantages of the Unix approach.

One should always try to delegate as much functionality as possible to
user-level processes as the shell, this is more error-prone and secure. Also,
when implementing this functionality at the shell, access to executables and
paths is isolated by default.

## System Calls

#### DATA STRUCTURES

>B1: Copy here the declaration of each new or changed struct or struct member,
>global or static variable, typedef, or enumeration.  Identify the purpose of
>each in 25 words or less.

No new data structure was added.


>B2: Describe how file descriptors are associated with open files. Are file
>descriptors unique within the entire OS or just within a single process?

File descriptors, in contrast to inodes, are unique only within the process they
were opened at, inodes are the only, afaik, universally unique identifiers for
files.


#### ALGORITHMS

>B3: Describe your code for reading and writing user data from the kernel.



>B4: Suppose a system call causes a full page (4,096 bytes) of data to be copied
>from user space into the kernel.  What is the least and the greatest possible
>number of inspections of the page table (e.g. calls to pagedir_get_page()) that
>might result?  What about for a system call that only copies 2 bytes of data?
>Is there room for improvement in these numbers, and how much?



>B5: Briefly describe your implementation of the "wait" system call and how it
>interacts with process termination.

Each process (thread) stores a single "wait lock" semaphore inside its pcb, this
is initialized as 0 in `init_thread`, when a thread "waits" on a another one,
what actually happens is that it tries to "`sema_down`" the `wait_lock`,
blocking itself until the owner thread releases the lock.

```c
int
process_wait (tid_t child_tid UNUSED)
{
    DEBUGPRINT("process_wait was called from thread %d\n", thread_current()->tid);
    struct thread* child_thr = find_by_tid(child_tid);
    if (child_thr == NULL)
        return -1;

    DEBUGPRINT("found! %d, thread %d is getting locked away...\n", child_thr->tid, thread_current()->tid);
    if (child_thr->pcb.proc_stat == RUNNING)
        sema_down(&child_thr->pcb.wait_lock);
    DEBUGPRINT("thread %d was unlocked\n", thread_current()->tid);

    return child_thr->pcb.xstat;
}
```

Also, at any given time, the `exit` syscall stores the exit value inside the
`thread::pcb::xstat`. Once the waiting thread stops waiting, it returns the
xstat from the thread it was waiting for.

>B6: Any access to user program memory at a user-specified address can fail due
>to a bad pointer value.  Such accesses must cause the process to be terminated.
>System calls are fraught with such accesses, e.g. a "write" system call
>requires reading the system call number from the user stack, then each of the
>call's three arguments, then an arbitrary amount of user memory, and any of
>these can fail at any point.  This poses a design and error-handling problem:
>how do you best avoid obscuring the primary function of code in a morass of
>error-handling?  Furthermore, when an error is detected, how do you ensure that
>all temporarily allocated resources (locks, buffers, etc.) are freed?  In a few
>paragraphs, describe the strategy or strategies you adopted for managing these
>issues.  Give an example.

All resources are owned by the functions they are called at, no copies are done
and everything is managed in its own context so `thread_exit()` can free
everything that needs to be freed.

#### SYNCHRONIZATION

>B8: Consider parent process P with child process C.  How do you ensure proper
>synchronization and avoid race conditions when P calls wait(C) before C exits?
>After C exits?  How do you ensure that all resources are freed in each case?
>How about when P terminates without waiting, before C exits?  After C exits?
>Are there any special cases?

1. How do you ensure proper synchronization and avoid race conditions when P
   calls wait(C) before C exits?

Each thread implements a running semaphore for other threads to lock and wait on.

2. How do you ensure proper synchronization and avoid race conditions when P
   calls wait(C) after C exits?

If C already exited, its `xstat` is simply returned and there is no further waiting.

3. How do you ensure that all resources are freed in each case?

Both `thread_exit` and `process_exit` cleanup all resources from all threads.

#### RATIONALE

>B9: Why did you choose to implement access to user memory from the kernel in
>the way that you did?

I used a generic macro that adapts to distinct pointer sizes to test the
boundary fits of certain pointers within the allowed memory sections in the
kernel. This allows for a simpler pointer testing and faster execution with
lesser cache misses.

>B10: What advantages or disadvantages can you see to your design for file
>descriptors?

I used tid's instead of pid's because PintOS is designed to be run in a single
processor machine with virtual threads, so, technically, each thread can be its
own process. In multi-processor environments, this can't be done and, instead,
each PID should be created as a runtime-generated locally-unique integer to
maintain a stable synchronization system.

>B11: The default tid_t to pid_t mapping is the identity mapping. If you changed
>it, what advantages are there to your approach?

It allowed for universal process waiting, taking tid's from the `all_list` of
threads and simpler logic overall. However, it is very non-standard and, as said
previously, may break multi-processor synchronization.


