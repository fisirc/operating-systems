# Stack growth

## Data structures

### `thread.c`

```c
struct thread
{
  // ...
  void *esp;
  struct hash spt;
  // ... 
}
```

`esp` stores the stack pointer of the thread, which is useful to know if an access to the stack is valid or not. `spt` is a hash table that stores the supplemental page table of the thread.

## Algorithms

## `page_fault`

```c
static void
page_fault (struct intr_frame *f) 
{
  // ...
  void * upage = pg_round_down (fault_addr);
  struct hash * spt = &(thread_current()->spt);
  struct spe * spe = get_spte(spt, upage);
  void * esp = user ? f->esp : thread_current()->esp;

  if (
    PHYS_BASE <= fault_addr + MAX_STACK_SIZE &&
    esp <= fault_addr + 32 &&
    !get_spte(spt, fault_addr)
  )
    init_zero_spte (spt, upage);

  if (!load_page (spt, upage)) {
    return;
  }
  // ...
}
```

`page_fault` now checks if the fault address is within the stack boundary and if the fault address is within 32 bytes of the stack pointer. If both conditions are met, it initializes a zero page for the fault address. Then, it loads the page from the supplemental page table.
